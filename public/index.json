
[{"content":"","date":"May 4 2024","externalUrl":null,"permalink":"stevenml.com/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":"\rLinkedIn Resume GitHub I am a computer graphics engineer with a passion for real-time rendering and game engine development. I mainly have experience with C++, OpenGL, and Vulkan. Currently, I am working on an open-source game engine, Vang, that utilizes ray marching inside large, realistic, cuboid environments. Originally coming from a game development background, I have extensively worked with various commercial game engines such as Unity, Unreal, and GameMaker. I hope to use my experience to develop tools that make creating immersive environments more streamlined and accessible to everyone.\n","date":"May 4 2024","externalUrl":null,"permalink":"stevenml.com/","section":"Steven Lawrence","summary":"LinkedIn Resume GitHub I am a computer graphics engineer with a passion for real-time rendering and game engine development.","title":"Steven Lawrence","type":"page"},{"content":"","date":"May 4 2024","externalUrl":null,"permalink":"stevenml.com/projects/vang/releases/v0.0.1/","section":"Projects","summary":"Greedy Cuboid Plane-Assisted Ray-Marching","title":"v0.0.1","type":"projects"},{"content":"","date":"May 4 2024","externalUrl":null,"permalink":"stevenml.com/projects/vang/releases/","section":"Projects","summary":"All releases for Vang","title":"Vang Releases","type":"projects"},{"content":"\rVang is a Ray-Marching Voxel Engine developed by me! #\rlawrencemsteven/Vang\rC\u0026#43;\u0026#43; 1\r0\rDevelopment started in November 2022 and has been going strong ever since. I have been able use the engine for my bachelor\u0026rsquo;s thesis for my 2024 graduation from Drexel University. The goal of the paper is to is to demonstrate a more efficient to ray-march a large voxel scene than traditional methods such as using a voxel octree or standard plane-assisted ray marching.\nHere are a few showcases of some of the engine\u0026rsquo;s features:\n","date":"April 25 2024","externalUrl":null,"permalink":"stevenml.com/projects/vang/","section":"Projects","summary":"Voxel Abstraction Engine","title":"Vang","type":"projects"},{"content":"Building on Plane-Assisted Ray Marching, we can group similar voxels together and then travel through the entire cuboid at once.\nFor example, if a chunk, which is 64x64, consists entirely of air blocks. We could group them together as one block instead and state that a ray within that chunk can do the next ray-plane intersection at the farthest area. To do this it requires storing more information inside of each block.\nCurrently, the block contains 34 bits of information about the block, stating what type it is. Then it has another 30 bits for the cuboid information. 5 bits correspond to each direction which means that the maximum size for a cuboid is 32x32. So 5 bits are how far the cuboid stretches in the positive X direction, another 5 bits correspond to how far the cuboid stretches in the negative X direction, etc.\nThis allows for much more efficient ray traversal since the cuboid information and the block information is received entirely in one texture call and then the ray-plane intersection function just offsets the plane in the given direction by the stated amount. Much larger scenes can be rendered at a much higher framerate.\nBelow is the new ray iteration loop in GLSL. This definitely needs to be optimized and cleaned up later on but for the research paper that I want to get finished before May 20th 2024, I am pretty happy with where it currently is.\nThe most important thing is that now the currentblock is represented with two 32bit unsigned intergers. The red channel or first component represent the block type (0 is void, 1 is air, 2 is fog). The green channel or second component represents the cuboid information. This will keep traveling until it hits a block that is not air, fog, or glass (1, 2, or 15), or if the ray has traveled for 1048 cuboids. (There was previous support for basic entities but that is not currently implemented)\nfloat totalDistance = 0.0f; ivec3 currentBlockPos = getBlockCoords(rayOrigin); uvec2 previousBlock = getBlockInfo(currentBlockPos); uvec2 currentBlock = previousBlock; int blockSteps = 0; float fogAmount = 0.0f; float glassAmount = 0.0f; bool entityHit = false; while ((currentBlock.r == 1 || currentBlock.r == 2 || currentBlock.r == 15) \u0026amp;\u0026amp; blockSteps \u0026lt; 1048 \u0026amp;\u0026amp; !entityHit) {\tvec3 signedDirection = sign(rayDirection); ivec3 distDir = ivec3(round(signedDirection.x), 0, 0); float cuboidModifier = signedDirection.x \u0026gt; 0 ? getCuboidPositiveX(currentBlock.g) : -1 * float(getCuboidNegativeX(currentBlock.g)); vec3 planeOrigin = vec3(float(currentBlockPos.x) + 0.5f * signedDirection.x + cuboidModifier, currentBlockPos.yz); vec3 planeNormal = vec3(-sign(rayDirection.x), 0.0f, 0.0f); float minDist = planeIntersectionDistance(rayOrigin, rayDirection, planeOrigin, planeNormal); cuboidModifier = signedDirection.y \u0026gt; 0 ? getCuboidPositiveY(currentBlock.g) : -1 * float(getCuboidNegativeY(currentBlock.g)); planeOrigin = vec3(currentBlockPos.x, float(currentBlockPos.y) + 0.5f * signedDirection.y + cuboidModifier, currentBlockPos.z); planeNormal = vec3(0.0f, -sign(rayDirection.y), 0.0f); float newDist = planeIntersectionDistance(rayOrigin, rayDirection, planeOrigin, planeNormal); if (newDist \u0026lt; minDist) { distDir = ivec3(0, round(signedDirection.y), 0); minDist = newDist; } cuboidModifier = signedDirection.z \u0026gt; 0 ? getCuboidPositiveZ(currentBlock.g) : -1 * float(getCuboidNegativeZ(currentBlock.g)); planeOrigin = vec3(currentBlockPos.xy, float(currentBlockPos.z) + 0.5f * signedDirection.z + cuboidModifier); planeNormal = vec3(0.0f, 0.0f, -sign(rayDirection.z)); newDist = planeIntersectionDistance(rayOrigin, rayDirection, planeOrigin, planeNormal); if (newDist \u0026lt; minDist) { distDir = ivec3(0, 0, round(signedDirection.z)); minDist = newDist; } // Fog if (currentBlock.r == 2) { fogAmount += minDist; } // Glass if (currentBlock.r == 15) { glassAmount += minDist; } entityHit = entityCheck(rayOrigin, rayDirection, minDist); if (!entityHit) { rayOrigin += rayDirection * minDist; currentBlockPos = getBlockCoords(rayOrigin + 0.5 * distDir); previousBlock = currentBlock; currentBlock = getBlockInfo(currentBlockPos); totalDistance += minDist; blockSteps += 1; if (currentBlock.r == 15 \u0026amp;\u0026amp; previousBlock.r != 15) { // Going into glass const vec3 normal = -vec3(distDir); rayDirection = refract(rayDirection, normal, glassRefractionIndex); } else if (previousBlock.r == 15 \u0026amp;\u0026amp; currentBlock.r != 15) { // Coming out of glass const vec3 normal = -vec3(distDir); rayDirection = refract(rayDirection, normal, glassRefractionIndex); } } } ","date":"April 21 2024","externalUrl":null,"permalink":"stevenml.com/projects/vang/greedycuboidoptimization/","section":"Projects","summary":"Grouping similar blocks into one large cuboid for more efficient ray traversal","title":"Greedy Cuboid Optimization","type":"projects"},{"content":"When a ray enters a block of glass, using Snell\u0026rsquo;s Law, the direction of the ray is changed. This happens again when exiting a block of glass. This allows for some interesting looking light refractions where the rays seem to bend the longer thay travel through the glass.\nI used a fantastic tutorial on how to do reflections, refractions, and a fresnel effect to achieve the refractions. This is a wonderful guide on how it works in the real world and how it can be achieved within a ray tracing engine.\nI want to add reflections but this is a bit trickier. To add reflections I would recursively call the raycast function to instance another ray; however, GLSL does not support recursion. This means that I have to get a little tricky with how to instantiate another raycast and store its information. I will want to set the maximum number of reflections to do this and probably loop over it for however many reflections are needed. For now though I am happy with this effect and it is very interesting to see how the light changes in some weird shapes with the glass.\n","date":"April 7 2024","externalUrl":null,"permalink":"stevenml.com/projects/vang/accurateglassrefractions/","section":"Projects","summary":"When rays enter and exit glass, the direction changes","title":"Accurate Glass Refractions","type":"projects"},{"content":"\rlawrencemsteven/BFBB\rC# 0\r0\rDownload In Beat Flavor: Breakfast Boogie, players take on the role of a breakfast establishment employee who is responsible for managing and serving different customers inside the restaurant. Throughout their time managing the restaurant, the player will be able to make upgrades to their stations and add different designs to the restaurant. Everything that the player does must be done to the beat, from flipping pancakes to washing dishes.\nThis project was made as part of a 12 person team for Junior design project 2 at Drexel. I was the producer on the team and I mostly managed the programming team as well as the documentation. Towards the end of our project I also worked on a lot of the polish work for the project such as the menus, screen transitions, and shop.\nProbably the most important tool that I created for the team was an interpolation library called Interpolawrence. This was meant to give smooth or fast transitions to any zero to one value. I used this for our games camera transitions in the menu. It is also used on the individual menu transitions when the screens slide from top to bottom. Even the egg dancing animation is run using the same interpolating functions.\npublic class Interpolawrence : MonoBehaviour { public enum InterpolawrenceSpeeds { Quick, Slow } public static float Lerp(InterpolawrenceSpeeds startSpeed, InterpolawrenceSpeeds stopSpeed, float amount) { if (startSpeed == InterpolawrenceSpeeds.Slow \u0026amp;\u0026amp; stopSpeed == InterpolawrenceSpeeds.Slow) { float transitionAmount = Mathf.Lerp(0.0f, Mathf.PI, amount); return 0.5f * Mathf.Sin(transitionAmount - Mathf.PI / 2.0f) + 0.5f; } else if (startSpeed == InterpolawrenceSpeeds.Quick \u0026amp;\u0026amp; stopSpeed == InterpolawrenceSpeeds.Quick) { float transitionAmount = Mathf.Lerp(0.0f, Mathf.PI, amount); if (transitionAmount \u0026lt; 0.5f) { return Mathf.Sin(transitionAmount) * 0.5f; } else { return Mathf.Abs(Mathf.Sin(transitionAmount) * 0.5f - 1.0f); } } else if (startSpeed == InterpolawrenceSpeeds.Slow \u0026amp;\u0026amp; stopSpeed == InterpolawrenceSpeeds.Quick) { float transitionAmount = Mathf.Lerp(0.0f, Mathf.PI / 2.0f, amount); return Mathf.Sin(transitionAmount - Mathf.PI / 2.0f) + 1.0f; } else if (startSpeed == InterpolawrenceSpeeds.Quick \u0026amp;\u0026amp; stopSpeed == InterpolawrenceSpeeds.Slow) { float transitionAmount = Mathf.Lerp(0.0f, Mathf.PI / 2.0f, amount); return Mathf.Sin(transitionAmount); } return -1.0f; } } Beat Flavor: Breakfast Boogie was definitely difficult to work on such a large team and within such a short time span being only 10 weeks. However, I really enjoyed working with this team and I am happy with our end result.\n","date":"March 21 2024","externalUrl":null,"permalink":"stevenml.com/projects/unity/bfbb/","section":"Projects","summary":"Serve up rhythm, make an unbeatable flavor","title":"Beat Flavor: Breakfast Boogie","type":"projects"},{"content":"","date":"March 21 2024","externalUrl":null,"permalink":"stevenml.com/projects/unity/","section":"Projects","summary":"Game Design Projects","title":"Unity","type":"projects"},{"content":"\rOnce a ray is traveling through the scene it keeps track of how far it has traveled within the fog block. That amount is then used at the end to change the resulting pixel color and add more of the fog color the farther it has traveled. The larger the fog volume, the more the fog color is shown.\n","date":"February 18 2024","externalUrl":null,"permalink":"stevenml.com/projects/vang/basicvolumetricclouds/","section":"Projects","summary":"Fog is represented with a block that a ray can travel though","title":"Basic Volumetric Fog","type":"projects"},{"content":"From the main camera a screen is projected in the direction that the player is stated to be looking. Then that screen is divided up by the number of pixels in the viewport and a ray is created for each one. Then there is a ray origin (camera origin) and a direction to travel.\nSo first the ray will check the sides of the cube that it is currently in to see which one it will hit. This is done through a ray-plane intersection which returns a point. Using the distance to that point we can find the surface that will be hit. After doing three ray-place intersections, which ever has the shortest distance is the surface that is hit.\nThere is also no need to check for all six planes of the cube since, in the X direction, the ray can only be traveling in either positive X, negative X, or is parallel to the x axis. So the first test is to figure out which of these states it is in. For simplicity the case where it is parallel is ignored and treated as postiive X. Doing this for each axis means we only need to check three surfaces. Next we can start the raymarch and keep traveling until a block is hit.\nIt will travel block by block until eventually a block is hit. Currently this will just return a solid color for the block but this can easily be turned into UV coordinates using the intersection point.\nBelow I have included a snippet of the ray marching function in GLSL. It will check the three plane intersections and take the minimum. After that it will repeat traveling block by block until eventually it hits a block to stop at.\nThis code still has to be cleaned up and there are definitely ways that I can optimize it further but I am happy with where it currently is for the result I am looking for!\nfloat totalDistance = 0.0f; ivec3 currentBlockPos = getBlockCoords(rayOrigin); uint previousBlock = getBlock(currentBlockPos); uint currentBlock = previousBlock; int blockSteps = 0; float fogAmount = 0.0f; float glassAmount = 0.0f; bool entityHit = false; while ((currentBlock == 1 || currentBlock == 2 || currentBlock == 15) \u0026amp;\u0026amp; blockSteps \u0026lt; 1048 \u0026amp;\u0026amp; !entityHit) { if (rayDirection.x == 0.0 \u0026amp;\u0026amp; rayDirection.y == 0.0 \u0026amp;\u0026amp; rayDirection.z == 0.0) { imageStore(screen, pixel_coords, vec4(1.0f, 1.0f, 1.0f, 1.0f)); return; } vec3 signedDirection = sign(rayDirection); if (signedDirection.x == 0 \u0026amp;\u0026amp; signedDirection.y == 0 \u0026amp;\u0026amp; signedDirection.z == 0) { imageStore(screen, pixel_coords, vec4(0.0f, 0.0f, 1.0f, 1.0f)); return; } ivec3 distDir = ivec3(round(signedDirection.x), 0, 0); float minDist = planeIntersectionDistance(rayOrigin, rayDirection, vec3(currentBlockPos.x + 0.5f * signedDirection.x, currentBlockPos.yz), vec3(-sign(rayDirection.x), 0.0f, 0.0f)); float newDist = planeIntersectionDistance(rayOrigin, rayDirection, vec3(currentBlockPos.x, currentBlockPos.y + 0.5f * signedDirection.y, currentBlockPos.z), vec3(0.0f, -sign(rayDirection.y), 0.0f)); if (newDist \u0026lt; minDist) { distDir = ivec3(0, round(signedDirection.y), 0); minDist = newDist; } newDist = planeIntersectionDistance(rayOrigin, rayDirection, vec3(currentBlockPos.xy, currentBlockPos.z + 0.5f * signedDirection.z), vec3(0.0f, 0.0f, -sign(rayDirection.z))); if (newDist \u0026lt; minDist) { distDir = ivec3(0, 0, round(signedDirection.z)); minDist = newDist; } // Fog if (currentBlock == 2) { fogAmount += minDist; } // Glass if (currentBlock == 15) { glassAmount += minDist; } entityHit = entityCheck(rayOrigin, rayDirection, minDist); if (!entityHit) { currentBlockPos += distDir; previousBlock = currentBlock; currentBlock = getBlock(currentBlockPos); rayOrigin += rayDirection * minDist; totalDistance += minDist; blockSteps += 1; if (currentBlock == 15 \u0026amp;\u0026amp; previousBlock != 15) { // Going into glass const vec3 normal = -vec3(distDir); rayDirection = refract(rayDirection, normal, glassRefractionIndex); } else if (previousBlock == 15 \u0026amp;\u0026amp; currentBlock != 15) { // Coming out of glass const vec3 normal = -vec3(distDir); rayDirection = refract(rayDirection, normal, glassRefractionIndex); } } } ","date":"January 15 2024","externalUrl":null,"permalink":"stevenml.com/projects/vang/plane-assistedraymarching/","section":"Projects","summary":"Rays travel block by block until they hit a block and a color is returned","title":"Plane-Assisted Ray Marching","type":"projects"},{"content":"\rJjman739/InsiderPerspective\rC# 0\r0\rDownload Insider Perspective involves a camera technician who is working as a CCTV personnel inside the esteemed megabucks manor, looking to get the money he\u0026rsquo;s owed. Steel A. Lotta has worked for his boss, Jimmy D. Bucks, for a while now and Jimmy has stopped paying him. Jimmy however is still spending money on his precious relics to store around his manor. Steelâ€™s friend, Slip N. Anout, convinces him to collect the money he\u0026rsquo;s owed. Play as Steel and use the CCTV cameras to navigate a delivery bot throughout the manor, collecting any relics you can find to reclaim your missing paychecks.\nThis project was made as part of a six person team for Junior design project 1 at Drexel. I was the producer on the team organizing team operations and fascilitating communication with our publisher the professor. I also worked on the different camera shaders that were featured in the game. Here is some examples of what was available:\nI was happy to get to work on the camera shaders. All of them are image space shaders that just change the resulting image in some way. For example, the inverted one just inverts all the colors in the image. It was a fun introduction to working with shaders within Unity.\nI also enjoyed being the producer on the team. This mean that I had to keep our GitHub organized as well as keep assigned tasks in order. This was my first time as a producer but I enjoyed the challenge and enjoyed making sure everyone was happy to work on the game!\n","date":"December 18 2023","externalUrl":null,"permalink":"stevenml.com/projects/unity/insiderperspective/","section":"Projects","summary":"It helps to have eyes on the inside","title":"Insider Perspective","type":"projects"},{"content":"","date":"January 9 2023","externalUrl":null,"permalink":"stevenml.com/projects/gamemaker/","section":"Projects","summary":"Various 2D Pixel Projects","title":"GameMaker Studio","type":"projects"},{"content":"\rPlay Here The goal of this project was to see how close to a finished game I could get within a week of time.\nThe game is a simple matching game where the player must make a match of four cards in order to get their bonus. Then they can try to match some of the other cards!\nThere is a total of 6 cards in the game that correspond to health, dodge, attack, poison, block, and regeneration. The effects would stack for each card that the player would get.\nOne of the most important things that I had to realize for this assignment is that I did not have a lot of time to work on this. I needed to find what was going to give me the most benefit for the least amount of time. For this I decided to work on the animations for the cards such as the card shuffling and card flipping. It seems small but I think it really helps to boost the overall look and polish of the game. The animations were entirely programmatic so it was fun to use math to try and generate animations. This is one of the first times that I have tried this outside of my animation class.\n","date":"January 9 2023","externalUrl":null,"permalink":"stevenml.com/projects/gamemaker/thematchine/","section":"Projects","summary":"Card Matching game made solo in a week","title":"The MATCHine","type":"projects"},{"content":"\rPlay Here Bulletopia was my first Unity project and this was a solo project.\nHere, I made a simple shooter that as the game went on, the player would collect upgrade points to buff their character. They buffs are as follows:\nShooting Speed Reload Speed Bullet Damage Ammo Count Walking Speed Jump Height There was also three weapons that were unlockable for the player:\nPistol (Starter Weapon) Submachine Gun Assault Rifle This project provided me with a very good understanding of how to use Unity and some of the tools that it provided.\n","date":"December 5 2022","externalUrl":null,"permalink":"stevenml.com/projects/unity/bulletopia/","section":"Projects","summary":"It helps to have eyes on the inside","title":"Bulletopia","type":"projects"},{"content":"After my modeling course at Drexel, I took an animation course. This course went over the fundamentals of animation on Maya.\n","date":"October 24 2022","externalUrl":null,"permalink":"stevenml.com/projects/animation/mayaanimation/","section":"Projects","summary":"Animation projects in Maya","title":"Maya Animation","type":"projects"},{"content":"Before Drexel I started to learn a bit of 3D modeling using blender. After that I took a modeling an animation course, using Maya, at Drexel to learn the fundamentals. I definitely prefer to use Blender since I find it much easier to work with and I also believe that it crashes a lot less!\n","date":"October 1 2022","externalUrl":null,"permalink":"stevenml.com/projects/animation/","section":"Projects","summary":"Maya and Blender Projects","title":"Modeling \u0026 Animation","type":"projects"},{"content":"This project served as an way to learn to Unreal Engine 5. The goal was to setup a simple cave generation algorithm. Here is a demo showcasing the end result:\nThere was a total of 17 possible layouts for the caves to generate within a 3D hexagonal grid layout. Here is an image of all the possible layouts:\nThe blue number corresponds to the nunber of entries to the rooms. The red number is just an index. The engine will start with one enterance on one side and then connects to another room type. It also supports traveling vertically within the 3D space as well. This system was meant for a game where each segment could be handcrafted as some cave segment then each of the pieces can be stitched together to have some random generation with individual hand-crafted rooms.\nOverall, the project was a great introduction to Unreal Engine and I really enjoyed working with their blueprint system. I had a lot of fun just making sure that it looked clean and was easily readable through functions.\nLastly, I did also get to experiment with creating some of my own blueprint functions in C++ since they were just too complicated for blueprint alone. I was surprised with how easy it was to handle data between each and it is pretty interesting to see how blueprint can be very user friendly and simple for people to prototype in. Meanwhile, you can still have people in the backend working on individual blueprint components for anything too complicated or performance heavy.\n","date":"June 8 2022","externalUrl":null,"permalink":"stevenml.com/projects/unreal/cavegeneration/","section":"Projects","summary":"Use Blueprint and C++ to generate a cave system for a game.","title":"Cave Generation","type":"projects"},{"content":"","date":"June 8 2022","externalUrl":null,"permalink":"stevenml.com/projects/unreal/","section":"Projects","summary":"Try out blueprint and C++","title":"Unreal Engine","type":"projects"},{"content":"While at Drexel, I took a course on 3D modeling. In that class I learned the fundamentals of some more advanced modeling techniques as well as texture mapping. Here is a showcase of the projects that I was able to create within that class:\nProbably the most important thing I learned in the class is about the different map types. Such as albedo, roughness, and normal maps. I had no idea what any of these were prior to this class and it has help in future projects to know about these different maps and how they interact with light rays when rendering.\n","date":"March 11 2022","externalUrl":null,"permalink":"stevenml.com/projects/animation/mayamodeling/","section":"Projects","summary":"Modeling projects in Maya","title":"Maya Modeling","type":"projects"},{"content":"\rBluetooth LED Controller #\rlawrencemsteven/Bluetooth-LED-Lighting-Android-App\rAn Android app which will send a Bluetooth message to an Arduino to change the colors on an LED Strip.\rJava 1\r0\rThis project started slightly before I began college. I wanted to have an LED strip in my room that I could change the colors with using an app. I wanted more customization though was typically offered. For this I wired up an LED strip to an Arduino and then wrote some functionality that would parse a string for the color information. Now I connected to the arduino through bluetooth using my Android phone and created an app that would send the string information to the Arduino.\nThis supported a solid color where the LED strip would just be one color.\nA gradient that could be selected with up to four colors. This would then be able to cycle around the room with the gradient moving with it.\nParty mode, a color is randomly selected every given time interval.\nMy wire management was not the best, but the end result created some pretty cool lights for my freshman dorm!\n","date":"January 14 2021","externalUrl":null,"permalink":"stevenml.com/projects/other/blc/","section":"Projects","summary":"Bluetooth LED Controller Android App","title":"BLC","type":"projects"},{"content":"","date":"January 14 2021","externalUrl":null,"permalink":"stevenml.com/projects/other/","section":"Projects","summary":"A few other miscellaneous projects","title":"Other","type":"projects"},{"content":"\rPlay Here This project was created on a team with two other people. One artist, one musician, and I was the programmer. This game was pretty fun to work on since I got to create a few new systems.\nOne of the systems that I created was an inventory system. It was a lot more challenging than I origionally imagined and proved to be one of the most challenging things for this project. There were different types of inventory slots so that the furnace for example would only take anything that could be cooked in the top slot and only take fuel in the bottom slot. I also wanted to include the basic features such as item sorting and item stacking.\n","date":"November 2 2020","externalUrl":null,"permalink":"stevenml.com/projects/gamemaker/metallicrops/","section":"Projects","summary":"Survival matallic plant growing game","title":"Metallicrops Prototype","type":"projects"},{"content":"This was my freshman design project at Drexel. This project was made over two quarters so there was a total of 20 weeks.\nIn this game four players will split up and have to take control of their ship. There are four rooms within the ship, Shields, Oxygen Generator, Weapon, and Printer. The printer will make the supplies needed for each of the other rooms.\n","date":"June 4 2020","externalUrl":null,"permalink":"stevenml.com/projects/gamemaker/cosmicredshift/","section":"Projects","summary":"Four player space ship battler","title":"Cosmic Redshift","type":"projects"},{"content":"Before freshman year in college I wanted to try out some 3D modeling to see what that was like. First I followed a tutorial to create the following two scenes:\nThey were very simple low-poly scenes that mostly just used the basic blender shapes. These gave me the fundamentals to go on and start doing my own projects. Then I created the following three images:\nI am happy with how these turned out and it was a good introduction to the absolute basics of 3D modeling.\n","date":"August 14 2019","externalUrl":null,"permalink":"stevenml.com/projects/animation/blendermodeling/","section":"Projects","summary":"Modeling projects in Blender","title":"Blender Modeling","type":"projects"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"stevenml.com/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"stevenml.com/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"\rGlodon USA March 2022 - December 2023\rSoftware Engineer\rWorked on a small graphics team in various areas for CAD modeling software related to architecture\rWrote python bindings for graphics related functions on the C++ backend\rUnderstood 3rd party code for future extension and developed documentation based on the code base\rMoberg Analytics February 2021 - January 2022\rClinical Informatics Engineer\rFull Stack development using Flask and React to create a medical dashboard which enables doctors to analyze patient data\rCreated an interactive drag and drop analytic constructor and custom data visualizations using D3.js\rMet weekly with Doctors and a team from IBM about development for the patient data dashboard\rDrexel CCI September 2020 - March 2021\rTeaching Assistant\rAssist professor in conducting weekly labs\rGrade written assignments and lab reports\rProvide assistance to students on course subject matter\r","date":"January 1 0001","externalUrl":null,"permalink":"stevenml.com/employment/","section":"Steven Lawrence","summary":"Glodon USA March 2022 - December 2023\rSoftware Engineer\rWorked on a small graphics team in various areas for CAD modeling software related to architecture\rWrote python bindings for graphics related functions on the C++ backend\rUnderstood 3rd party code for future extension and developed documentation based on the code base\rMoberg Analytics February 2021 - January 2022\rClinical Informatics Engineer\rFull Stack development using Flask and React to create a medical dashboard which enables doctors to analyze patient data\rCreated an interactive drag and drop analytic constructor and custom data visualizations using D3.","title":"Employment History","type":"page"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"stevenml.com/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"stevenml.com/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]